explicit representation,
objects represented by polygons, through their points, edges and faces

implicit representation,
geometrical objects such as spheres, cones, cylinders, tori (pl. torus), etc. which
can't be explicitly represented but implicitly through a mathematical expression:

implicit representation are usually represented as a mapping from 3d-space to 1d-real-numbers
like so:

[first, new, cool, math thing!]

f:R^3 -> R, where points given:
f(x,y,z) // our R^3
will evaluate into three regions zero, positive and negative:

f(x,y,z) = 0 // boundary of the object
f(x,y,z) > 0 // exterior of the object
f(x,y,z) < 0 // interior of the object

awesome!

Example for a sphere:
x^2 + y^2 + z^2 <= r^2    // works!

This is like a double Pythagorean theorem on the left side the resulting
distance is, if equal r^2, a point _on_ the sphere

(defun sphere-collision-p (x y z sphere-radius)
  "Returns true if the point P(x,y,z) lies within or touches the sphere of radius:
   sphere-radius."
  (<= (apply #'+
	     (mapcar #'(lambda (x) (expt x 2))
		     (list x y z)))
      (expt sphere-radius 2)))

Through understanding that this is just a double-pythagoras we can formulate a collision
test for a 2d-circle easily:
x^2 + y^2 <= r^2  (awesome number two!)

An object boundary defined in such a way is called an /implicit surface/!

Advantages:
- quick rejection culling (is it in the interior = CULL it out!)
- fast intersection test: well simply feed a point into the f(x,y,z) function and you know
  if it is inside or toughing the boundary: f(x,y,z) =< 0!

half-space,
we cut space in two along an infinite plane. The resulting two spaces left and right of
the plane are infinitely large but still just half-spaces of a bigger infinity!

convex objects (polygon),
any two points within this object can connect in a straight line without leaving the region of
the object. We need this word because collision tests are much easier with such objects!
Foreshadowing: we will probably try to break concave polygons into smaller convex objects?

concave polygon object,
opposite of convex object. Contains an interior angle greater than 180-degrees.

half-space intersection representation (convex objects only),
another way to represent polygonal objects, here we cut away some space with planes and use
the resulting half-space intersections to represent an object. An example would be to represent
a rectangle in 2d by using two x-axis values to cut away the two sides - resulting in an
infinitely long rectangle along the y axis- then provide two y-axis to encompass a finitely
big rectangle! (see texatl.cl:space for this kind of rectangle representation!)
This is reminiscent of the aabb test!

--------------------------------------------------------------------------------
We won't usually use the same geometry for collision as for rendering
Pros:
- it is usually to complex, and collision test don't need to be that precise
- the usual triangle representation of objets are harder to querry for collision
  then other shapes like spheres, for example
- rendering data may be organized in a quite a different way than is useful for
  collision. Collision tests probably want spatial hierarchical relationships
  whereas rendering data will create topologies for adjacent vertices at best
  and material attributes, color and texture coordinates at worst (useless for
  collision tests!)
- orgainising for collision tests makes the data smaller hence more efficient to
  use and coherent in memory and useful for further extension and tests tailored
  for collision
- sometimes you want to explicitly differ, for example the plane representing
  snow might be intentionally lowered in the proxy geometry to allow knee-deep
  movement in the snow. Instead for exclusion tests, just use a differnt geometry
  to begin with.
- even if rendering data is not needed because an object is not visible it is
  still needed for collision. Just imagine walking behind a wall, where the
  camera sees the wall it will usually cull out everything behind it, you should
  however still follow the law's of physics even when nobody is around to see it!

Cons:
- Data duplication. Could be solved by inferring the proxy geometry from the rendering
  geometry (through linearization caching)!!
- time to build the tools that generate the geometry or more time for the designer
  to create the his models
- visual consistency may suffer: objects may float above others, or fully intersect
  (surely you seen the animations which simply move through anything when they parts
   of it move outside the hitbox)
- interdependency problems: if the rendering geometry changes, the collision geometry
  might also have to change, and how is this process automated. Which of the two
  geometry comes first?

we use, hence, another geometry instead.. as a proxy:

proxy geometry,
the collision test geometry for objects. This usually reduces the complex rendering
geometry by encapsulating a object of intrest into a:

bounding volume,
a simpler geometrical object like a box or a sphere representing the object in a
simpler way than the actual rendering geometry for the sake of a simpler easier
collision test!

--------------------------------------------------------------------------------
Types of queries:

interference detection or intersection testing,
yes/no did the objects collide, do they intersect?
Easy to implement, commonly used

intersection finding,
WHERE did they intersect?
